<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wizard: sockpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Wizard
   </div>
   <div id="projectbrief">Software Engineering Project - Wizard</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">sockpp</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md467"></a></p>
<p><a href="https://travis-ci.org/fpagliughi/sockpp"><img src="https://travis-ci.org/fpagliughi/sockpp.svg?branch=master" alt="Build Status" style="pointer-events: none;" class="inline"/></a></p>
<p>Simple, modern, C++ socket library.</p>
<p>This is a fairly low-level C++ wrapper around the Berkeley sockets library using <code>socket</code>, <code>acceptor,</code> and <code>connector</code> classes that are familiar concepts from other languages.</p>
<p>The base <code>socket</code> class wraps a system socket handle, and maintains its lifetime. When the C++ object goes out of scope, it closes the underlying socket handle. Socket objects are generally <em>moveable</em> but not <em>copyable</em>. A socket can be transferred from one scope (or thread) to another using <code>std::move()</code>.</p>
<p>Currently supports: IPv4, IPv6, and Unix-Domain Sockets on Linux, Mac, and Windows. Other *nix and POSIX systems should work with little or no modification.</p>
<p>All code in the library lives within the <code>sockpp</code> C++ namespace.</p>
<h1><a class="anchor" id="autotoc_md468"></a>
Latest News</h1>
<p>The library is reaching a stable API, and is on track for a 1.0 release in the near future. Until then, there may be a few more breaking changes, but hopefully those will be fewer than we have seen so far.</p>
<p>On that note, despite being recently refactored and re-versioned at 0.x, earlier implementations of this library have been in use on production systems since ~2003, particularly with remote embedded Linux data loggers. Things that we now call IoT gateways and edge devices. It can be counted on to be reliable.</p>
<p>To keep up with the latest announcements for this project, follow me at:</p>
<p><b>Twitter:</b> <a href="https://twitter.com/fmpagliughi">@fmpagliughi</a></p>
<p>If you're using this library, tweet at me or send me a message, and let me know how you're using it. I'm always curious to see where it's wound up!</p>
<h1><a class="anchor" id="autotoc_md469"></a>
Unreleased Features in this Branch</h1>
<p>The following updates exist in this branch in the repository, but have yet to be formally released:</p>
<ul>
<li>[#37] socket::get_option() not returning length on Windows.</li>
<li>[#39] Using <em>SSIZE_T</em> for <em>ssize_t</em> in Windows</li>
<li>Now <code>acceptor::open()</code> uses the <em>SO_REUSEPORT</em> option instead of <em>SO_REUSEADDR</em> on non-Windows systenms. Also made reuse optional.</li>
</ul>
<h1><a class="anchor" id="autotoc_md470"></a>
New in v0.7</h1>
<p>This release mainly targeted bug fixes, API inconsistencies, and numerous small features that had been overlooked previously.</p>
<ul>
<li><a class="el" href="class_base.html">Base</a> <code>socket</code> class<ul>
<li><code>shutdown()</code> added</li>
<li><code>create()</code> added</li>
<li><code>bind()</code> moved into base socket (from <code>acceptor</code>)</li>
</ul>
</li>
<li>Unix-domain socket pairs (stream and datagram)</li>
<li>Non-blocking I/O</li>
<li>Scatter/Gather I/O</li>
<li><code>stream_socket</code> cloning.</li>
<li>Set and get socket options using template types.</li>
<li><code>stream_socket::read_n()</code> and <code>write_n()</code> now properly handle EINTR return.</li>
<li><code>to_timeval()</code> can convert from any <code>std::chrono::duration</code> type.</li>
<li><code>socket::close()</code> and <code>shutdown()</code> check for errors, set last error, and return a bool.</li>
<li><em>tcpechomt.cpp</em>: Example of a client sharing a socket between read and write threads - using <code>clone()</code>.</li>
<li>Windows enhancements:<ul>
<li>Implemented socket timeouts on Windows</li>
<li>Fixed bug in Windows socket cloning.</li>
<li>Fixed bug in Windows <code>socket::last_error_string</code>.</li>
<li>Unit tests working on Windows</li>
</ul>
</li>
<li>More unit tests</li>
</ul>
<h1><a class="anchor" id="autotoc_md471"></a>
Contributing</h1>
<p>Contributions are accepted and appreciated. New and unstable work is done in the <code>develop</code> branch Please submit all pull requests against that branch, not <em>master</em>.</p>
<p>For more information, refer to: <a href="https://github.com/fpagliughi/sockpp/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a></p>
<h1><a class="anchor" id="autotoc_md472"></a>
TODO</h1>
<ul>
<li><b>Unit Tests</b> - The framework for unit and regression tests is in place (using <em>Catch2</em>), along with the GitHub Travis CI integration. But the library could use a lot more tests.</li>
<li><b>Consolidate Header Files</b> - The last round of refactoring left a large number of header files with a single line of code in each. This may be OK, in that it separates all the protocols and families, but seems a waste of space.</li>
<li><b>Secure Sockets</b> - It would be extremely handy to have support for SSL/TLS built right into the library as an optional feature.</li>
<li><b>SCTP</b> - The <em>SCTP</em> protocol never caught on, but it seems intriguing, and might be nice to have in the library for experimentation, if not for some internal applications.</li>
</ul>
<h1><a class="anchor" id="autotoc_md473"></a>
Building the Library</h1>
<p>CMake is the supported build system.</p>
<h2><a class="anchor" id="autotoc_md474"></a>
Requirements:</h2>
<ul>
<li>A conforming C++-14 compiler.<ul>
<li><em>gcc</em> v5.0 or later (or) <em>clang</em> v3.8 or later.</li>
<li><em>Visual Studio 2015</em>, or later on WIndows.</li>
</ul>
</li>
<li><em>CMake</em> v3.5 or newer.</li>
<li><em>Doxygen</em> (optional) to generate API docs.</li>
<li><em>Catch2</em> (optional) to build and run unit tests.</li>
</ul>
<p>Build like this on Linux:</p>
<div class="fragment"><div class="line">$ cd sockpp</div>
<div class="line">$ mkdir build ; cd build</div>
<div class="line">$ cmake ..</div>
<div class="line">$ make</div>
<div class="line">$ sudo make install</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md475"></a>
Build Options</h2>
<p>The library has several build options via CMake to choose between creating a static or shared (dynamic) library - or both. It also allows you to build the example options, and if Doxygen is</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Variable   </th><th class="markdownTableHeadNone">Default Value   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SOCKPP_BUILD_SHARED   </td><td class="markdownTableBodyNone">ON   </td><td class="markdownTableBodyNone">Whether to build the shared library    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">SOCKPP_BUILD_STATIC   </td><td class="markdownTableBodyNone">OFF   </td><td class="markdownTableBodyNone">Whether to build the static library    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SOCKPP_BUILD_DOCUMENTATION   </td><td class="markdownTableBodyNone">OFF   </td><td class="markdownTableBodyNone">Create and install the HTML based API documentation (requires <em>Doxygen)</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">SOCKPP_BUILD_EXAMPLES   </td><td class="markdownTableBodyNone">OFF   </td><td class="markdownTableBodyNone">Build example programs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SOCKPP_BUILD_TESTS   </td><td class="markdownTableBodyNone">OFF   </td><td class="markdownTableBodyNone">Build the unit tests (requires <em>Catch2</em>)   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md476"></a>
TCP Sockets</h1>
<p>TCP and other "streaming" network applications are usually set up as either servers or clients. An acceptor is used to create a TCP/streaming server. It binds an address and listens on a known port to accept incoming connections. When a connection is accepted, a new, streaming socket is created. That new socket can be handled directly or moved to a thread (or thread pool) for processing.</p>
<p>Conversely, to create a TCP client, a connector object is created and connected to a server at a known address (typically host and socket). When connected, the socket is a streaming one which can be used to read and write, directly.</p>
<p>For IPv4 the <code>tcp_acceptor</code> and <code>tcp_connector</code> classes are used to create servers and clients, respectively. These use the <code>inet_address</code> class to specify endpoint addresses composed of a 32-bit host address and a 16-bit port number.</p>
<h2><a class="anchor" id="autotoc_md477"></a>
TCP Server: <code>tcp_acceptor</code></h2>
<p>The <code>tcp_acceptor</code> is used to set up a server and read_message for incoming connections. </p><pre class="fragment">int16_t port = 12345;
sockpp::tcp_acceptor acc(port);

if (!acc)
    report_error(acc.last_error_str());

// Accept a new client connection
sockpp::tcp_socket sock = acc.accept();
</pre><p>The acceptor normally sits in a loop accepting new connections, and passes them off to another process, thread, or thread pool to interact with the client. In standard C++, this could look like: </p><pre class="fragment">while (true) {
    // Accept a new client connection
    sockpp::tcp_socket sock = acc.accept();

    if (!sock) {
        cerr &lt;&lt; "Error accepting incoming connection: "
            &lt;&lt; acc.last_error_str() &lt;&lt; endl;
    }
    else {
        // Create a thread and transfer the new stream to it.
        thread thr(run_echo, std::move(sock));
        thr.detach();
    }
}
</pre><p>The hazards of a thread-per-connection design is well documented, but the same technique can be used to pass the socket into a thread pool, if one is available.</p>
<p>See the <a href="https://github.com/fpagliughi/sockpp/blob/master/examples/tcp/tcpechosvr.cpp">tcpechosvr.cpp</a> example.</p>
<h2><a class="anchor" id="autotoc_md478"></a>
TCP Client: <code>tcp_connector</code></h2>
<p>The TCP client is somewhat simpler in that a <code>tcp_connector</code> object is created and connected, then can be used to read and write data directly. </p><pre class="fragment">sockpp::tcp_connector _conn;
int16_t port = 12345;

if (!_conn.connect(sockpp::inet_address("localhost", port)))
    report_error(_conn.last_error_str());

_conn.write_n("Hello", 5);

char buf[16];
ssize_t n = _conn.read(buf, sizeof(buf));
</pre><p>See the <a href="https://github.com/fpagliughi/sockpp/blob/master/examples/tcp/tcpecho.cpp">tcpecho.cpp</a> example.</p>
<h2><a class="anchor" id="autotoc_md479"></a>
UDP Socket: <code>udp_socket</code></h2>
<p>UDP sockets can be used for connectionless communications: </p><pre class="fragment">sockpp::udp_socket sock;
sockpp::inet_address addr("localhost", 12345);

std::string msg("Hello there!");
sock.send_to(msg, addr);

sockpp::inet_address srcAddr;

char buf[16];
ssize_t n = sock.recv(buf, sizeof(buf), &amp;srcAddr);
</pre><p>See the <a href="https://github.com/fpagliughi/sockpp/blob/master/examples/udp/udpecho.cpp">udpecho.cpp</a> and <a href="https://github.com/fpagliughi/sockpp/blob/master/examples/udp/udpechosvr.cpp">udpechosvr.cpp</a> examples. </p>
<h2><a class="anchor" id="autotoc_md480"></a>
IPv6</h2>
<p>The same style of connectors and acceptors can be used for TCP connections over IPv6 using the classes: </p><pre class="fragment">inet6_address
tcp6_connector
tcp6_acceptor
tcp6_socket
udp6_socket
</pre><p>Examples are in the <a href="https://github.com/fpagliughi/sockpp/tree/master/examples/tcp">examples/tcp</a> directory.</p>
<h2><a class="anchor" id="autotoc_md481"></a>
Unix Domain Sockets</h2>
<p>The same is true for local connection on *nix systems that implement Unix Domain Sockets. For that use the classes: </p><pre class="fragment">unix_address
unix_connector
unix_acceptor
unix_socket  (unix_stream_socket)
unix_dgram_socket
</pre><p>Examples are in the <a href="https://github.com/fpagliughi/sockpp/tree/master/examples/unix">examples/unix</a> directory.</p>
<h1><a class="anchor" id="autotoc_md482"></a>
Implementation Details</h1>
<p>The socket class hierarchy is built upon a base <code>socket</code> class. Most simple applications will probably not use <code>socket</code> directly, but rather use top-level classes defined for a specific address family like <code>tcp_connector</code> and <code>tcp_acceptor</code>.</p>
<p>The socket objects keep a handle to an underlying OS socket handle and a cached value for the last error that occurred for that socket. The socket handle is typically an integer file descriptor, with values &gt;=0 for open sockets, and -1 for an unopened or invalid socket. The value used for unopened sockets is defined as a constant, <code>INVALID_SOCKET</code>, although it usually doesn't need to be tested directly, as the object itself will evaluate to <em>false</em> if it's uninitialized or in an error state. A typical error check would be like this: </p><pre class="fragment">tcp_connector _conn({"localhost", 12345});

if (!_conn)
    cerr &lt;&lt; _conn.last_error_str() &lt;&lt; std::endl;
</pre><p>The default constructors for each of the socket classes do nothing, and simply set the underlying handle to <code>INVALID_SOCKET</code>. They do not create a socket object. The call to actively connect a <code>connector</code> object or open an <code>acceptor</code> object will create an underlying OS socket and then perform the requested operation.</p>
<p>An application can generally perform most low-level operations with the library. Unconnected and unbound sockets can be created with the static <code>create()</code> function in most of the classes, and then manually bind and read_message on those sockets.</p>
<p>The <code>socket::handle()</code> method exposes the underlying OS handle which can then be sent to any platform API call that is not exposed by the library.</p>
<h2><a class="anchor" id="autotoc_md483"></a>
Thread Safety</h2>
<p>A socket object is not thread-safe. Applications that want to have multiple threads reading from a socket or writing to a socket should use some form of serialization, such as a <code>std::mutex</code> to protect access.</p>
<p>A <code>socket</code> can be <em>moved</em> from one thread to another safely. This is a common pattern for a server which uses one thread to accept incoming connections and then passes off the new socket to another thread or thread pool for handling. This can be done like: </p><pre class="fragment">sockpp::tcp6_socket sock = acc.accept(&amp;peer);

// Create a thread and transfer the new socket to it.
std::thread thr(handle_connection, std::move(sock));
</pre><p>In this case, <em>handle_connection</em> would be a function that takes a socket by value, like: </p><pre class="fragment">void handle_connection(sockpp::tcp6_socket sock) { ... }
</pre><p>Since a <code>socket</code> can not be copied, the only choice would be to move the socket to a function like this.</p>
<p>It is a common patern, especially in client applications, to have one thread to read from a socket and another thread to write to the socket. In this case the underlying socket handle can be considered thread safe (one read thread and one write thread). But even in this scenario, a <code><a class="el" href="classsockpp_1_1socket.html">sockpp::socket</a></code> object is still not thread-safe due especially to the cached error value. The write thread might see an error that happened on the read thread and visa versa.</p>
<p>The solution for this case is to use the <code>socket::clone()</code> method to make a copy of the socket. This will use the system's <code>dup()</code> function or similar create another socket with a duplicated copy of the socket handle. This has the added benefit that each copy of the socket can maintain an independent lifetime. The underlying socket will not be closed until both objects go out of scope. </p><pre class="fragment">sockpp::tcp_connector _conn({host, port});

auto rdSock = _conn.clone();
std::thread rdThr(read_thread_func, std::move(rdSock));
</pre><p>The <code>socket::shutdown()</code> method can be used to communicate the intent to close the socket from one of these objects to the other without needing another thread signaling mechanism.</p>
<p>See the <a href="https://github.com/fpagliughi/sockpp/blob/master/examples/tcp/tcpechomt.cpp">tcpechomt.cpp</a> example. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
